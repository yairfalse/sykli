defmodule Sykli.Module.Codegen.Rust do
  @moduledoc """
  Generates Rust SDK code from a Sykli module JSON schema.

  The generated code follows the existing Rust SDK conventions:
  - Struct with configuration fields
  - Default trait implementation
  - tasks() method that registers tasks with a Pipeline
  - validate() method for required field checking
  """

  @doc """
  Generate Rust code from a module JSON schema.

  Returns `{:ok, code, path}` or `{:error, reason}`.
  """
  def generate(schema) when is_map(schema) do
    module_name = schema["name"] |> extract_struct_name()
    group = schema["group"]
    params = schema["params"] || []

    code = """
    // Code generated by sykli module gen. DO NOT EDIT.
    // Source: #{schema["name"]}

    use sykli::Pipeline;

    /// #{module_name} - #{schema["params"] |> List.first() |> get_in(["doc"]) || "Generated module"}
    #[derive(Clone, Debug)]
    pub struct #{module_name} {
    #{generate_struct_fields(params)}
    }

    impl Default for #{module_name} {
        fn default() -> Self {
            Self {
    #{generate_default_impl(params)}
            }
        }
    }

    impl #{module_name} {
        /// Create a new instance with required fields.
        pub fn new(#{generate_constructor_params(params)}) -> Self {
            Self {
    #{generate_constructor_body(params)}
                ..Default::default()
            }
        }

        /// Register this module's tasks with the pipeline.
        pub fn tasks(&self, p: &mut Pipeline) {
            self.validate().expect("validation failed");

            // TODO: Implement task generation
            // This is a placeholder - actual task logic depends on module implementation
        }

        /// Validate that required fields are set.
        pub fn validate(&self) -> Result<(), String> {
    #{generate_validation(params)}
            Ok(())
        }
    }
    """

    path = "rust/modules/#{group}/src/#{snake_case(module_name)}.rs"
    {:ok, code, path}
  rescue
    e -> {:error, Exception.message(e)}
  end

  # Extract struct name from full module name
  defp extract_struct_name(name) when is_binary(name) do
    name
    |> String.split(".")
    |> List.last()
  end

  defp extract_struct_name(_), do: "Module"

  # Generate Rust struct fields from params
  defp generate_struct_fields(params) do
    params
    |> Enum.map(fn param ->
      name = param["name"]
      type = rust_type(param["type"], param["required"])
      doc = param["doc"]

      field = "    pub #{name}: #{type},"

      if doc do
        "    /// #{doc}\n#{field}"
      else
        field
      end
    end)
    |> Enum.join("\n\n")
  end

  # Generate Default trait implementation
  defp generate_default_impl(params) do
    params
    |> Enum.map(fn param ->
      name = param["name"]
      default = param["default"]
      required = param["required"]

      value =
        cond do
          # Required field with no default - use type's zero value
          required && default == nil ->
            rust_none_or_default(param["type"])

          # Required field with default - use the default directly
          required && default != nil ->
            rust_literal(default, param["type"])

          # Optional field with default - wrap in Some()
          !required && default != nil ->
            "Some(#{rust_literal(default, param["type"])})"

          # Optional field with no default - None
          true ->
            "None"
        end

      "            #{name}: #{value},"
    end)
    |> Enum.join("\n")
  end

  # Generate constructor params (only required fields)
  defp generate_constructor_params(params) do
    params
    |> Enum.filter(& &1["required"])
    |> Enum.map(fn param ->
      name = param["name"]
      # Use concrete type for constructor, not Option
      type = rust_base_type(param["type"])
      "#{name}: #{type}"
    end)
    |> Enum.join(", ")
  end

  # Generate constructor body
  defp generate_constructor_body(params) do
    params
    |> Enum.filter(& &1["required"])
    |> Enum.map(fn param ->
      name = param["name"]
      "            #{name},"
    end)
    |> Enum.join("\n")
  end

  # Generate validation code
  defp generate_validation(params) do
    required_params = Enum.filter(params, & &1["required"])

    if Enum.empty?(required_params) do
      ""
    else
      required_params
      |> Enum.map(fn param ->
        name = param["name"]
        type = param["type"]

        check =
          case type do
            "string" -> "self.#{name}.is_empty()"
            _ -> "false" # Other types always have a value in Rust
          end

        """
                if #{check} {
                    return Err("#{name} is required".into());
                }\
        """
      end)
      |> Enum.join("\n")
    end
  end

  # Convert to Rust type (with Option wrapper for non-required)
  defp rust_type(type, required) do
    base = rust_base_type(type)

    if required do
      base
    else
      "Option<#{base}>"
    end
  end

  # Base Rust type without Option wrapper
  defp rust_base_type("string"), do: "String"
  defp rust_base_type("integer"), do: "i32"
  defp rust_base_type("boolean"), do: "bool"
  defp rust_base_type("list<string>"), do: "Vec<String>"
  defp rust_base_type("map<string, string>"), do: "std::collections::HashMap<String, String>"
  defp rust_base_type(other), do: "/* #{other} */ String"

  # Default/None value for type
  defp rust_none_or_default("string"), do: "String::new()"
  defp rust_none_or_default("integer"), do: "0"
  defp rust_none_or_default("boolean"), do: "false"
  defp rust_none_or_default("list<string>"), do: "Vec::new()"
  defp rust_none_or_default("map<string, string>"), do: "std::collections::HashMap::new()"
  defp rust_none_or_default(_), do: "None"

  # Convert value to Rust literal
  defp rust_literal(val, "string") when is_binary(val), do: "\"#{val}\".into()"
  defp rust_literal(val, "integer") when is_integer(val), do: "#{val}"
  defp rust_literal(true, "boolean"), do: "true"
  defp rust_literal(false, "boolean"), do: "false"
  defp rust_literal([], "list<string>"), do: "Vec::new()"
  defp rust_literal(%{}, "map<string, string>"), do: "std::collections::HashMap::new()"
  defp rust_literal(nil, _), do: "None"

  defp rust_literal(val, type) do
    inner_type = String.replace(type, ~r/^Option<(.+)>$/, "\\1")
    "Some(#{rust_literal(val, inner_type)})"
  end

  # Convert to snake_case for file names
  defp snake_case(name) when is_binary(name) do
    name
    |> String.replace(~r/([A-Z])/, "_\\1")
    |> String.downcase()
    |> String.trim_leading("_")
  end
end
