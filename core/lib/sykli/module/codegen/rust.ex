defmodule Sykli.Module.Codegen.Rust do
  @moduledoc """
  Generates Rust SDK code from a Sykli module JSON schema.

  The generated code follows the existing Rust SDK conventions:
  - Struct with configuration fields
  - Default trait implementation
  - tasks() method that registers tasks with a Pipeline
  - validate() method for required field checking
  """

  @doc """
  Generate Rust code from a module JSON schema.

  Returns `{:ok, code, path}` or `{:error, reason}`.
  """
  def generate(schema) when is_map(schema) do
    module_name = schema["name"] |> extract_struct_name()
    group = schema["group"]
    params = schema["params"] || []
    tasks = schema["tasks"] || []

    code = """
    // Code generated by sykli module gen. DO NOT EDIT.
    // Source: #{schema["name"]}

    use sykli::Pipeline;

    /// #{module_name} - #{schema["params"] |> List.first() |> get_in(["doc"]) || "Generated module"}
    #[derive(Clone, Debug)]
    pub struct #{module_name} {
    #{generate_struct_fields(params)}
    }

    impl Default for #{module_name} {
        fn default() -> Self {
            Self {
    #{generate_default_impl(params)}
            }
        }
    }

    impl #{module_name} {
        /// Create a new instance with required fields.
        pub fn new(#{generate_constructor_params(params)}) -> Self {
            Self {
    #{generate_constructor_body(params)}
                ..Default::default()
            }
        }

        /// Register this module's tasks with the pipeline.
        pub fn tasks(&self, p: &mut Pipeline) {
            self.validate().expect("validation failed");

    #{generate_tasks(tasks, params)}
        }

        /// Validate that required fields are set.
        pub fn validate(&self) -> Result<(), String> {
    #{generate_validation(params)}
            Ok(())
        }
    }
    """

    path = "rust/modules/#{group}/src/#{snake_case(module_name)}.rs"
    {:ok, code, path}
  rescue
    e -> {:error, Exception.message(e)}
  end

  # Extract struct name from full module name
  defp extract_struct_name(name) when is_binary(name) do
    name
    |> String.split(".")
    |> List.last()
  end

  defp extract_struct_name(_), do: "Module"

  # Generate Rust struct fields from params
  defp generate_struct_fields(params) do
    params
    |> Enum.map(fn param ->
      name = param["name"]
      type = rust_type(param["type"], param["required"])
      doc = param["doc"]

      field = "    pub #{name}: #{type},"

      if doc do
        "    /// #{doc}\n#{field}"
      else
        field
      end
    end)
    |> Enum.join("\n\n")
  end

  # Generate Default trait implementation
  defp generate_default_impl(params) do
    params
    |> Enum.map(fn param ->
      name = param["name"]
      default = param["default"]
      required = param["required"]

      value =
        cond do
          # Required field with no default - use type's zero value
          required && default == nil ->
            rust_none_or_default(param["type"])

          # Required field with default - use the default directly
          required && default != nil ->
            rust_literal(default, param["type"])

          # Optional field with default - wrap in Some()
          !required && default != nil ->
            "Some(#{rust_literal(default, param["type"])})"

          # Optional field with no default - None
          true ->
            "None"
        end

      "            #{name}: #{value},"
    end)
    |> Enum.join("\n")
  end

  # Generate constructor params (only required fields)
  defp generate_constructor_params(params) do
    params
    |> Enum.filter(& &1["required"])
    |> Enum.map(fn param ->
      name = param["name"]
      # Use concrete type for constructor, not Option
      type = rust_base_type(param["type"])
      "#{name}: #{type}"
    end)
    |> Enum.join(", ")
  end

  # Generate constructor body
  defp generate_constructor_body(params) do
    params
    |> Enum.filter(& &1["required"])
    |> Enum.map(fn param ->
      name = param["name"]
      "            #{name},"
    end)
    |> Enum.join("\n")
  end

  # Generate validation code
  defp generate_validation(params) do
    required_params = Enum.filter(params, & &1["required"])

    if Enum.empty?(required_params) do
      ""
    else
      required_params
      |> Enum.map(fn param ->
        name = param["name"]
        type = param["type"]

        check =
          case type do
            "string" -> "self.#{name}.is_empty()"
            # Other types always have a value in Rust
            _ -> "false"
          end

        """
                if #{check} {
                    return Err("#{name} is required".into());
                }\
        """
      end)
      |> Enum.join("\n")
    end
  end

  # Convert to Rust type (with Option wrapper for non-required)
  defp rust_type(type, required) do
    base = rust_base_type(type)

    if required do
      base
    else
      "Option<#{base}>"
    end
  end

  # Base Rust type without Option wrapper
  defp rust_base_type("string"), do: "String"
  defp rust_base_type("integer"), do: "i32"
  defp rust_base_type("boolean"), do: "bool"
  defp rust_base_type("list<string>"), do: "Vec<String>"
  defp rust_base_type("map<string, string>"), do: "std::collections::HashMap<String, String>"
  defp rust_base_type(other), do: "/* #{other} */ String"

  # Default/None value for type
  defp rust_none_or_default("string"), do: "String::new()"
  defp rust_none_or_default("integer"), do: "0"
  defp rust_none_or_default("boolean"), do: "false"
  defp rust_none_or_default("list<string>"), do: "Vec::new()"
  defp rust_none_or_default("map<string, string>"), do: "std::collections::HashMap::new()"
  defp rust_none_or_default(_), do: "None"

  # Convert value to Rust literal
  defp rust_literal(val, "string") when is_binary(val), do: "\"#{val}\".into()"
  defp rust_literal(val, "integer") when is_integer(val), do: "#{val}"
  defp rust_literal(true, "boolean"), do: "true"
  defp rust_literal(false, "boolean"), do: "false"
  defp rust_literal([], "list<string>"), do: "Vec::new()"
  defp rust_literal(%{}, "map<string, string>"), do: "std::collections::HashMap::new()"
  defp rust_literal(nil, _), do: "None"

  defp rust_literal(val, type) do
    inner_type = String.replace(type, ~r/^Option<(.+)>$/, "\\1")
    "Some(#{rust_literal(val, inner_type)})"
  end

  # Convert to snake_case for file names
  defp snake_case(name) when is_binary(name) do
    name
    |> String.replace(~r/([A-Z])/, "_\\1")
    |> String.downcase()
    |> String.trim_leading("_")
  end

  # Generate task creation code
  defp generate_tasks(tasks, params) do
    tasks
    |> Enum.map(fn task -> generate_task(task, params) end)
    |> Enum.join("\n\n")
  end

  defp generate_task(task, params) do
    name = task["name"]
    command = interpolate_command(task["command"], params)
    container = task["container"]
    depends_on = task["depends_on"] || []
    when_cond = task["when"]

    # Build the task chain
    chain = ["p.task(\"#{name}\")"]

    chain =
      if container do
        chain ++ [".container(\"#{container}\")"]
      else
        chain
      end

    chain = chain ++ [".run(#{command})"]

    chain =
      if length(depends_on) > 0 do
        deps = Enum.map(depends_on, fn d -> "\"#{d}\"" end) |> Enum.join(", ")
        chain ++ [".after(&[#{deps}])"]
      else
        chain
      end

    task_code = Enum.join(chain, "")

    # Handle conditional tasks
    case when_cond do
      %{"type" => "param", "field" => field} ->
        rust_field = field
        # Check if the field is a boolean (Option<bool>)
        param = Enum.find(params, fn p -> p["name"] == field end)
        is_required = param && param["required"]

        if is_required do
          # Required bool - just check directly
          """
                  if self.#{rust_field} {
                      #{task_code};
                  }\
          """
        else
          # Optional bool - use if let Some(true)
          """
                  if let Some(true) = self.#{rust_field} {
                      #{task_code};
                  }\
          """
        end

      nil ->
        "        #{task_code};"

      _ ->
        "        #{task_code};"
    end
  end

  # Interpolate ${param} in commands to Rust format!
  defp interpolate_command(nil, _params), do: "\"\""

  defp interpolate_command(cmd, params) do
    # Find all ${param} patterns
    param_names =
      Regex.scan(~r/\$\{(\w+)\}/, cmd)
      |> Enum.map(fn [_, param] -> param end)
      |> Enum.uniq()

    if Enum.empty?(param_names) do
      # No interpolation needed
      "\"#{cmd}\""
    else
      # Build format! call
      format_str = Regex.replace(~r/\$\{(\w+)\}/, cmd, "{}")

      args =
        param_names
        |> Enum.map(fn pname ->
          # Check if param is required or optional
          param = Enum.find(params, fn p -> p["name"] == pname end)
          is_required = param && param["required"]

          if is_required do
            "self.#{pname}"
          else
            # Unwrap Option with default
            "self.#{pname}.as_deref().unwrap_or(\"\")"
          end
        end)
        |> Enum.join(", ")

      "format!(\"#{format_str}\", #{args})"
    end
  end
end
