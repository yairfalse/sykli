defmodule Sykli.Module.Codegen.Go do
  @moduledoc """
  Generates Go SDK code from a Sykli module JSON schema.

  The generated code follows the existing Go SDK conventions:
  - Struct with configuration fields
  - Tasks() method that registers tasks with a Pipeline
  - Validate() method for required field checking
  """

  @doc """
  Generate Go code from a module JSON schema.

  Returns `{:ok, code, path}` or `{:error, reason}`.
  """
  def generate(schema) when is_map(schema) do
    module_name = schema["name"] |> extract_struct_name()
    group = schema["group"]
    params = schema["params"] || []

    code = """
    // Code generated by sykli module gen. DO NOT EDIT.
    // Source: #{schema["name"]}

    package #{group}

    import (
    \t"errors"
    \t"fmt"

    \tsykli "github.com/sykli-io/sykli-go"
    )

    // #{module_name} - #{schema["params"] |> List.first() |> get_in(["doc"]) || "Generated module"}
    type #{module_name} struct {
    #{generate_struct_fields(params)}
    }

    // Tasks registers the module's tasks with the pipeline.
    func (m *#{module_name}) Tasks(p *sykli.Pipeline) {
    \tm.applyDefaults()
    \tif err := m.Validate(); err != nil {
    \t\tpanic(err)
    \t}

    \t// TODO: Implement task generation
    \t// This is a placeholder - actual task logic depends on module implementation
    }

    // Validate checks that required fields are set.
    func (m *#{module_name}) Validate() error {
    #{generate_validation(params)}
    \treturn nil
    }

    // applyDefaults sets default values for unset fields.
    func (m *#{module_name}) applyDefaults() {
    #{generate_defaults(params)}
    }
    """

    path = "go/modules/#{group}/#{snake_case(module_name)}.go"
    {:ok, code, path}
  rescue
    e -> {:error, Exception.message(e)}
  end

  # Extract struct name from full module name
  # "Elixir.Sykli.Modules.Docker.BuildAndPush" -> "BuildAndPush"
  defp extract_struct_name(name) when is_binary(name) do
    name
    |> String.split(".")
    |> List.last()
  end

  defp extract_struct_name(_), do: "Module"

  # Generate Go struct fields from params
  defp generate_struct_fields(params) do
    params
    |> Enum.map(fn param ->
      name = param["name"] |> pascal_case()
      type = go_type(param["type"])
      doc = param["doc"]

      field = "\t#{name} #{type}"

      if doc do
        "\t// #{doc}\n#{field}"
      else
        field
      end
    end)
    |> Enum.join("\n\n")
  end

  # Generate validation code for required fields
  defp generate_validation(params) do
    required_params = Enum.filter(params, & &1["required"])

    if Enum.empty?(required_params) do
      ""
    else
      required_params
      |> Enum.map(fn param ->
        name = param["name"] |> pascal_case()
        type = param["type"]

        zero_check =
          case type do
            "string" -> "m.#{name} == \"\""
            "integer" -> "m.#{name} == 0"
            "boolean" -> "false" # booleans are never "missing"
            _ -> "m.#{name} == nil"
          end

        """
        \tif #{zero_check} {
        \t\treturn errors.New("#{name} is required")
        \t}\
        """
      end)
      |> Enum.join("\n")
    end
  end

  # Generate default value assignments
  defp generate_defaults(params) do
    params
    |> Enum.filter(& &1["default"] != nil)
    |> Enum.map(fn param ->
      name = param["name"] |> pascal_case()
      type = param["type"]
      default = param["default"]

      zero_check =
        case type do
          "string" -> "m.#{name} == \"\""
          "integer" -> "m.#{name} == 0"
          "boolean" -> nil # booleans always have a value
          _ -> nil
        end

      if zero_check do
        default_val = go_literal(default, type)

        """
        \tif #{zero_check} {
        \t\tm.#{name} = #{default_val}
        \t}\
        """
      else
        nil
      end
    end)
    |> Enum.reject(&is_nil/1)
    |> Enum.join("\n")
  end

  # Convert Elixir type to Go type
  defp go_type("string"), do: "string"
  defp go_type("integer"), do: "int"
  defp go_type("boolean"), do: "bool"
  defp go_type("list<string>"), do: "[]string"
  defp go_type("map<string, string>"), do: "map[string]string"
  defp go_type(other), do: "interface{} // #{other}"

  # Convert Elixir value to Go literal
  defp go_literal(val, "string") when is_binary(val), do: ~s("#{val}")
  defp go_literal(val, "integer") when is_integer(val), do: "#{val}"
  defp go_literal(true, "boolean"), do: "true"
  defp go_literal(false, "boolean"), do: "false"
  defp go_literal([], _), do: "nil"
  defp go_literal(%{}, _), do: "nil"
  defp go_literal(val, _), do: inspect(val)

  # Convert to PascalCase for Go exports
  defp pascal_case(name) when is_binary(name) do
    name
    |> String.split("_")
    |> Enum.map(&String.capitalize/1)
    |> Enum.join()
  end

  # Convert to snake_case for file names
  defp snake_case(name) when is_binary(name) do
    name
    |> String.replace(~r/([A-Z])/, "_\\1")
    |> String.downcase()
    |> String.trim_leading("_")
  end
end
