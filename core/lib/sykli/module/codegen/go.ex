defmodule Sykli.Module.Codegen.Go do
  @moduledoc """
  Generates Go SDK code from a Sykli module JSON schema.

  The generated code follows the existing Go SDK conventions:
  - Struct with configuration fields
  - Tasks() method that registers tasks with a Pipeline
  - Validate() method for required field checking
  """

  @doc """
  Generate Go code from a module JSON schema.

  Returns `{:ok, code, path}` or `{:error, reason}`.
  """
  def generate(schema) when is_map(schema) do
    module_name = schema["name"] |> extract_struct_name()
    group = schema["group"]
    params = schema["params"] || []
    tasks = schema["tasks"] || []

    code = """
    // Code generated by sykli module gen. DO NOT EDIT.
    // Source: #{schema["name"]}

    package #{group}

    import (
    \t"errors"
    \t"fmt"

    \tsykli "github.com/sykli-io/sykli-go"
    )

    // #{module_name} - #{schema["params"] |> List.first() |> get_in(["doc"]) || "Generated module"}
    type #{module_name} struct {
    #{generate_struct_fields(params)}
    }

    // Tasks registers the module's tasks with the pipeline.
    func (m *#{module_name}) Tasks(p *sykli.Pipeline) {
    \tm.applyDefaults()
    \tif err := m.Validate(); err != nil {
    \t\tpanic(err)
    \t}

    #{generate_tasks(tasks)}
    }

    // Validate checks that required fields are set.
    func (m *#{module_name}) Validate() error {
    #{generate_validation(params)}
    \treturn nil
    }

    // applyDefaults sets default values for unset fields.
    func (m *#{module_name}) applyDefaults() {
    #{generate_defaults(params)}
    }
    """

    path = "go/modules/#{group}/#{snake_case(module_name)}.go"
    {:ok, code, path}
  rescue
    e -> {:error, Exception.message(e)}
  end

  # Extract struct name from full module name
  # "Elixir.Sykli.Modules.Docker.BuildAndPush" -> "BuildAndPush"
  defp extract_struct_name(name) when is_binary(name) do
    name
    |> String.split(".")
    |> List.last()
  end

  defp extract_struct_name(_), do: "Module"

  # Generate Go struct fields from params
  defp generate_struct_fields(params) do
    params
    |> Enum.map(fn param ->
      name = param["name"] |> pascal_case()
      type = go_type(param["type"])
      doc = param["doc"]

      field = "\t#{name} #{type}"

      if doc do
        "\t// #{doc}\n#{field}"
      else
        field
      end
    end)
    |> Enum.join("\n\n")
  end

  # Generate validation code for required fields
  defp generate_validation(params) do
    required_params = Enum.filter(params, & &1["required"])

    if Enum.empty?(required_params) do
      ""
    else
      required_params
      |> Enum.map(fn param ->
        name = param["name"] |> pascal_case()
        type = param["type"]

        zero_check =
          case type do
            "string" -> "m.#{name} == \"\""
            "integer" -> "m.#{name} == 0"
            "boolean" -> "false" # booleans are never "missing"
            _ -> "m.#{name} == nil"
          end

        """
        \tif #{zero_check} {
        \t\treturn errors.New("#{name} is required")
        \t}\
        """
      end)
      |> Enum.join("\n")
    end
  end

  # Generate default value assignments
  defp generate_defaults(params) do
    params
    |> Enum.filter(& &1["default"] != nil)
    |> Enum.map(fn param ->
      name = param["name"] |> pascal_case()
      type = param["type"]
      default = param["default"]

      zero_check =
        case type do
          "string" -> "m.#{name} == \"\""
          "integer" -> "m.#{name} == 0"
          "boolean" -> nil # booleans always have a value
          _ -> nil
        end

      if zero_check do
        default_val = go_literal(default, type)

        """
        \tif #{zero_check} {
        \t\tm.#{name} = #{default_val}
        \t}\
        """
      else
        nil
      end
    end)
    |> Enum.reject(&is_nil/1)
    |> Enum.join("\n")
  end

  # Convert Elixir type to Go type
  defp go_type("string"), do: "string"
  defp go_type("integer"), do: "int"
  defp go_type("boolean"), do: "bool"
  defp go_type("list<string>"), do: "[]string"
  defp go_type("map<string, string>"), do: "map[string]string"
  defp go_type(other), do: "interface{} // #{other}"

  # Convert Elixir value to Go literal
  defp go_literal(val, "string") when is_binary(val), do: ~s("#{val}")
  defp go_literal(val, "integer") when is_integer(val), do: "#{val}"
  defp go_literal(true, "boolean"), do: "true"
  defp go_literal(false, "boolean"), do: "false"
  defp go_literal([], _), do: "nil"
  defp go_literal(%{}, _), do: "nil"
  defp go_literal(val, _), do: inspect(val)

  # Convert to PascalCase for Go exports
  defp pascal_case(name) when is_binary(name) do
    name
    |> String.split("_")
    |> Enum.map(&String.capitalize/1)
    |> Enum.join()
  end

  # Convert to snake_case for file names
  defp snake_case(name) when is_binary(name) do
    name
    |> String.replace(~r/([A-Z])/, "_\\1")
    |> String.downcase()
    |> String.trim_leading("_")
  end

  # Generate task creation code
  defp generate_tasks(tasks) do
    tasks
    |> Enum.map(&generate_task/1)
    |> Enum.join("\n\n")
  end

  defp generate_task(task) do
    name = task["name"]
    command = interpolate_command(task["command"])
    container = task["container"]
    depends_on = task["depends_on"] || []
    when_cond = task["when"]
    privileged = task["privileged"]

    # Build the task chain
    chain = ["p.Task(\"#{name}\")"]

    chain =
      if container do
        chain ++ [".Container(\"#{container}\")"]
      else
        chain
      end

    chain = chain ++ [".Run(#{command})"]

    chain =
      if privileged do
        # Note: Privileged isn't in the Go SDK yet, but we'll add it as a comment
        chain
      else
        chain
      end

    chain =
      if length(depends_on) > 0 do
        deps = Enum.map(depends_on, fn d -> "\"#{d}\"" end) |> Enum.join(", ")
        chain ++ [".After(#{deps})"]
      else
        chain
      end

    task_code = Enum.join(chain, "")

    # Handle conditional tasks
    case when_cond do
      %{"type" => "param", "field" => field} ->
        go_field = pascal_case(field)

        """
        \tif m.#{go_field} {
        \t\t#{task_code}
        \t}\
        """

      nil ->
        "\t#{task_code}"

      _ ->
        "\t#{task_code}"
    end
  end

  # Interpolate ${param} in commands to Go fmt.Sprintf
  defp interpolate_command(nil), do: ~s[""]

  defp interpolate_command(cmd) do
    # Find all ${param} patterns
    params =
      Regex.scan(~r/\$\{(\w+)\}/, cmd)
      |> Enum.map(fn [_, param] -> param end)
      |> Enum.uniq()

    if Enum.empty?(params) do
      # No interpolation needed
      "\"#{cmd}\""
    else
      # Build fmt.Sprintf call
      format_str =
        Regex.replace(~r/\$\{(\w+)\}/, cmd, "%s")

      args =
        params
        |> Enum.map(fn param -> "m.#{pascal_case(param)}" end)
        |> Enum.join(", ")

      "fmt.Sprintf(\"#{format_str}\", #{args})"
    end
  end
end
